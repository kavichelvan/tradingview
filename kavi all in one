//@version=5
//** SR, SMAs, Pivots, MSB-OB, SuperTrend, Volume based SR zones **//
indicator(title=' Kavi\'s primary', shorttitle=' Kavi\'s primary', overlay=true, max_bars_back=1000)
//
toggleBreaks = input(true, title='Show Breaks')
leftBars = input(15, title='Left Bars ')
rightBars = input(15, title='Right Bars')
volumeThresh = input(20, title='Volume Threshold')
//
highUsePivot = fixnan(ta.pivothigh(leftBars, rightBars)[1])
lowUsePivot = fixnan(ta.pivotlow(leftBars, rightBars)[1])
r1 = plot(highUsePivot, color=ta.change(highUsePivot) ? na : #FF0000, linewidth=3, offset=-(rightBars + 1), title='Resistance')
s1 = plot(lowUsePivot, color=ta.change(lowUsePivot) ? na : #233dee, linewidth=3, offset=-(rightBars + 1), title='Support')

//Volume %
short = ta.ema(volume, 5)
long = ta.ema(volume, 10)
osc = 100 * (short - long) / long


//For breaks with volume
plotshape(toggleBreaks and ta.crossunder(close, lowUsePivot) and not(open - close < high - open) and osc > volumeThresh, title='Break', text='B', style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 0), textcolor=color.new(color.white, 0), size=size.tiny)
plotshape(toggleBreaks and ta.crossover(close, highUsePivot) and not(open - low > close - open) and osc > volumeThresh, title='Break', text='B', style=shape.labelup, location=location.belowbar, color=color.new(color.green, 0), textcolor=color.new(color.white, 0), size=size.tiny)

//For bull / bear wicks
plotshape(toggleBreaks and ta.crossover(close, highUsePivot) and open - low > close - open, title='Break', text='Bull Wick', style=shape.labelup, location=location.belowbar, color=color.new(color.green, 0), textcolor=color.new(color.white, 0), size=size.tiny)
plotshape(toggleBreaks and ta.crossunder(close, lowUsePivot) and open - close < high - open, title='Break', text='Bear Wick', style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 0), textcolor=color.new(color.white, 0), size=size.tiny)


alertcondition(ta.crossunder(close, lowUsePivot) and osc > volumeThresh, title='Support Broken', message='Support Broken')
alertcondition(ta.crossover(close, highUsePivot) and osc > volumeThresh, title='Resistance Broken', message='Resistance Broken')

//** SMAs **//

// SMMA Config and declaration
smma_10 = input.int(10, minval=1, title='SMMA 10')
smma_21 = input.int(21, minval=1, title='SMMA 21')
smma_50 = input.int(50, minval=1, title='SMMA 50')
smma_100 = input.int(100, minval=1, title='SMMA 100')
smma_200 = input.int(200, minval=1, title='SMMA 200')
src = input(close, title='Source')

// SMMA calculating and drowing
smma10 = 0.0
smma21 = 0.0
smma50 = 0.0
smma100 = 0.0
smma200 = 0.0

smma10 := na(smma10[1]) ? ta.sma(src, smma_10) : (smma10[1] * (smma_10 - 1) + src) / smma_10
smma21 := na(smma21[1]) ? ta.sma(src, smma_21) : (smma21[1] * (smma_21 - 1) + src) / smma_21
smma50 := na(smma50[1]) ? ta.sma(src, smma_50) : (smma50[1] * (smma_50 - 1) + src) / smma_50
smma100 := na(smma100[1]) ? ta.sma(src, smma_100) : (smma100[1] * (smma_100 - 1) + src) / smma_100
smma200 := na(smma200[1]) ? ta.sma(src, smma_200) : (smma200[1] * (smma_200 - 1) + src) / smma_200
plot(smma10, color=#ffee00d7, title='SMMA 10', linewidth=2)
plot(smma21, color=color.new(#008cff, 0), title='SMMA 21', linewidth=2)
plot(smma50, color=color.new(#3bff45, 0), title='SMMA 50', linewidth=2)
plot(smma100, color=color.new(#ffffff, 0), title='SMMA 100', linewidth=2)
plot(smma200, color=color.new(#ff1e00, 0), title='SMMA 200', linewidth=2)

//** Pivots **//

pivotTypeInput = input.string(title="Type", defval="Traditional", options=["Traditional", "Fibonacci", "Woodie", "Classic", "DM", "Camarilla"])
pivotAnchorInput = input.string(title="Pivots Timeframe", defval="Auto", options=["Auto", "Daily", "Weekly", "Monthly", "Quarterly", "Yearly", "Biyearly", "Triyearly", "Quinquennially", "Decennially"])
maxHistoricalPivotsInput = input.int(title="Number of Pivots Back", defval=15, minval=1, maxval=200, display = display.data_window)
isDailyBasedInput = input.bool(title="Use Daily-based Values", defval=true, display = display.data_window, tooltip="When this option is unchecked, Pivot Points will use intraday data while calculating on intraday charts. If Extended Hours are displayed on the chart, they will be taken into account during the pivot level calculation. If intraday OHLC values are different from daily-based values (normal for stocks), the pivot levels will also differ.")
showLabelsInput = input.bool(title="Show Labels", defval=true, group="labels", display = display.data_window)
showPricesInput = input.bool(title="Show Prices", defval=true, group="labels", display = display.data_window)
positionLabelsInput = input.string("Left", "Labels Position", options=["Left", "Right"], group="labels", display = display.data_window)
linewidthInput = input.int(title="Line Width", defval=1, minval=1, maxval=100, group="levels", display = display.data_window)

DEFAULT_COLOR = #800080
NO_COLOR =  color.rgb(255, 255, 255)
pColorInput = input.color(DEFAULT_COLOR, "P‏  ‏  ‏", inline="P", group="levels", display = display.data_window)
pShowInput = input.bool(true, "", inline="P", group="levels", display = display.data_window)
s1ColorInput = input.color(DEFAULT_COLOR, "S1", inline="S1/R1" , group="levels", display = display.data_window)
s1ShowInput = input.bool(true, "", inline="S1/R1", group="levels", display = display.data_window)
r1ColorInput = input.color(DEFAULT_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R1", inline="S1/R1", group="levels", display = display.data_window)
r1ShowInput = input.bool(true, "", inline="S1/R1", group="levels", display = display.data_window)
s2ColorInput = input.color(NO_COLOR, "S2", inline="S2/R2", group="levels", display = display.data_window)
s2ShowInput = input.bool(true, "", inline="S2/R2", group="levels", display = display.data_window)
r2ColorInput = input.color(NO_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R2", inline="S2/R2", group="levels", display = display.data_window)
r2ShowInput = input.bool(true, "", inline="S2/R2", group="levels", tooltip = "Not applicable to DM", display = display.data_window)
s3ColorInput = input.color(NO_COLOR, "S3", inline="S3/R3", group="levels", display = display.data_window)
s3ShowInput = input.bool(true, "", inline="S3/R3", group="levels", display = display.data_window)
r3ColorInput = input.color(NO_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R3", inline="S3/R3", group="levels", display = display.data_window)
r3ShowInput = input.bool(true, "", inline="S3/R3", group="levels", tooltip = "Not applicable to DM", display = display.data_window)
s4ColorInput = input.color(NO_COLOR, "S4", inline="S4/R4", group="levels", display = display.data_window)
s4ShowInput = input.bool(true, "", inline="S4/R4", group="levels", display = display.data_window)
r4ColorInput = input.color(NO_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R4", inline="S4/R4", group="levels", display = display.data_window)
r4ShowInput = input.bool(true, "", inline="S4/R4", group="levels", tooltip = "Not applicable to: Fibonacci, DM", display = display.data_window)
s5ColorInput = input.color(NO_COLOR, "S5", inline="S5/R5", group="levels", display = display.data_window)
s5ShowInput = input.bool(true, "", inline="S5/R5", group="levels", display = display.data_window)
r5ColorInput = input.color(NO_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R5", inline="S5/R5", group="levels", display = display.data_window)
r5ShowInput = input.bool(true, "", inline="S5/R5", group="levels", tooltip = "Not applicable to: Fibonacci, Woodie, Classic, DM", display = display.data_window)

type graphicSettings
    string levelName
    color levelColor
    bool showLevel

var graphicSettingsArray = array.from(
      graphicSettings.new(" P", pColorInput, pShowInput),
      graphicSettings.new("R1", r1ColorInput, r1ShowInput), graphicSettings.new("S1", s1ColorInput, s1ShowInput),
      graphicSettings.new("R2", r2ColorInput, r2ShowInput), graphicSettings.new("S2", s2ColorInput, s2ShowInput),
      graphicSettings.new("R3", r3ColorInput, r3ShowInput), graphicSettings.new("S3", s3ColorInput, s3ShowInput),
      graphicSettings.new("R4", r4ColorInput, r4ShowInput), graphicSettings.new("S4", s4ColorInput, s4ShowInput),
      graphicSettings.new("R5", r5ColorInput, r5ShowInput), graphicSettings.new("S5", s5ColorInput, s5ShowInput))

autoAnchor = switch
    timeframe.isintraday => timeframe.multiplier <= 15 ? "1D" : "1W"
    timeframe.isdaily    => "1M"
    => "12M"

pivotTimeframe = switch pivotAnchorInput
    "Auto"      => autoAnchor
    "Daily"     => "1D"
    "Weekly"    => "1W"
    "Monthly"   => "1M"
    "Quarterly" => "3M"
    => "12M"

//@variable The number of years in the selected Pivot period
pivotYearMultiplier = switch pivotAnchorInput
    "Biyearly"       => 2
    "Triyearly"      => 3
    "Quinquennially" => 5
    "Decennially"    => 10
    => 1

//@variable The number of values in the pivots of the selected type
numOfPivotLevels = switch pivotTypeInput
    "Traditional" => 11
    "Camarilla"   => 11
    "Woodie"      => 9
    "Classic"     => 9
    "Fibonacci"   => 7
    "DM"          => 3

type pivotGraphic
    line pivotLine
    label pivotLabel

method delete(pivotGraphic graphic) =>
    graphic.pivotLine.delete()
    graphic.pivotLabel.delete()

var drawnGraphics = matrix.new<pivotGraphic>()

localPivotTimeframeChange = timeframe.change(pivotTimeframe) and year % pivotYearMultiplier == 0
securityPivotTimeframeChange = timeframe.change(timeframe.period) and year % pivotYearMultiplier == 0

pivotTimeframeChangeCounter(condition) => 
    var count = 0
    if condition and bar_index > 0
        count += 1
    count

localPivots = ta.pivot_point_levels(pivotTypeInput, localPivotTimeframeChange)
securityPivotPointsArray = ta.pivot_point_levels(pivotTypeInput, securityPivotTimeframeChange)

securityTimeframe = timeframe.isintraday ? "1D" : timeframe.period
[securityPivots, securityPivotCounter] = request.security(syminfo.tickerid, pivotTimeframe, [securityPivotPointsArray, pivotTimeframeChangeCounter(securityPivotTimeframeChange)], lookahead = barmerge.lookahead_on)
pivotPointsArray = isDailyBasedInput ? securityPivots : localPivots

//@function Sets the ending points of the currently active pivots to `endTime`.
affixOldPivots(endTime) =>
    if drawnGraphics.rows() > 0
        lastGraphics = drawnGraphics.row(drawnGraphics.rows() - 1)

        for graphic in lastGraphics
            graphic.pivotLine.set_x2(endTime)
            if positionLabelsInput == "Right"
                graphic.pivotLabel.set_x(endTime)

//@function Draws pivot lines and labels from `startTime` to the approximate end of the period.
drawNewPivots(startTime) =>
    
    newGraphics = array.new<pivotGraphic>()

    for [index, coord] in pivotPointsArray
        levelSettings = graphicSettingsArray.get(index)
        if not na(coord) and levelSettings.showLevel
            lineEndTime = startTime + timeframe.in_seconds(pivotTimeframe) * 1000 * pivotYearMultiplier
            pivotLine = line.new(startTime, coord, lineEndTime, coord, xloc = xloc.bar_time, color=levelSettings.levelColor, width=linewidthInput)
            pivotLabel = label.new(x = positionLabelsInput == "Left" ? startTime : lineEndTime,
                               y = coord,
                               text = (showLabelsInput ? levelSettings.levelName + " " : "") + (showPricesInput ? "(" + str.tostring(coord, format.mintick) + ")" : ""),
                               style = positionLabelsInput == "Left" ? label.style_label_right : label.style_label_left,
                               textcolor = levelSettings.levelColor,
                               color = #00000000,
                               xloc=xloc.bar_time)
            
            newGraphics.push(pivotGraphic.new(pivotLine, pivotLabel))
    
    drawnGraphics.add_row(array_id = newGraphics)

    if drawnGraphics.rows() > maxHistoricalPivotsInput
        oldGraphics = drawnGraphics.remove_row(0)
        
        for graphic in oldGraphics
            graphic.delete()


localPivotDrawConditionStatic = not isDailyBasedInput and localPivotTimeframeChange
securityPivotDrawConditionStatic = isDailyBasedInput and securityPivotCounter != securityPivotCounter[1]

var isMultiYearly = array.from("Biyearly", "Triyearly", "Quinquennially", "Decennially").includes(pivotAnchorInput)
localPivotDrawConditionDeveloping = not isDailyBasedInput and time_close == time_close(pivotTimeframe) and not isMultiYearly 
securityPivotDrawConditionDeveloping = false

if (securityPivotDrawConditionStatic or localPivotDrawConditionStatic)
    affixOldPivots(time)
    drawNewPivots(time)

// If possible, draw pivots from the beginning of the chart if none were found
var FIRST_BAR_TIME = time
if (barstate.islastconfirmedhistory and drawnGraphics.columns() == 0)

    if not na(securityPivots) and securityPivotCounter > 0
        if isDailyBasedInput
            drawNewPivots(FIRST_BAR_TIME)
        else 
            runtime.error("Not enough intraday data to calculate Pivot Points. Lower the Pivots Timeframe or turn on the 'Use Daily-based Values' option in the indicator settings.")
    else
        runtime.error("Not enough data to calculate Pivot Points. Lower the Pivots Timeframe in the indicator settings.")


//** Secondary indicators **//
//** MSB-OB, SuperTrend, Volume based SR zones **//

//indicator(" Kavi\'s secondary", " Kavi\'s secondary", overlay=true, max_lines_count=500, max_bars_back=4900, max_boxes_count=500)

//** MSB-OB **//

settings = "Settings"
zigzag_len = input.int(9, "ZigZag Length", group=settings)
show_zigzag = input.bool(true, "Show Zigzag", group=settings)
fib_factor = input.float(0.33, "Fib Factor for breakout confirmation", 0, 1, 0.01, group=settings)

text_size = input.string(size.tiny, "Text Size", [size.tiny, size.small, size.normal, size.large, size.huge], group=settings)

delete_boxes = input.bool(true, "Delete Old/Broken Boxes", group=settings)

bu_ob_inline_color = "Bu-OB Colors"
be_ob_inline_color = "Be-OB Colors"
bu_bb_inline_color = "Bu-BB Colors"
be_bb_inline_color = "Be-BB Colors"

bu_ob_display_settings = "Bu-OB Display Settings"
bu_ob_color = input.color(color.new(color.green, 70), "Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_border_color = input.color(color.green, "Border Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_text_color = input.color(color.green, "Text Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)

be_ob_display_settings = "Be-OB Display Settings"
be_ob_color = input.color(color.new(color.red, 70), "Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_border_color = input.color(color.red, "Border Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_text_color = input.color(color.red, "Text Color", group=be_ob_display_settings, inline=be_ob_inline_color)

bu_bb_display_settings = "Bu-BB & Bu-MB Display Settings"
bu_bb_color = input.color(color.new(color.green, 70), "Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_border_color = input.color(color.green, "Border Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_text_color = input.color(color.green, "Text Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)

be_bb_display_settings = "Be-BB & Be-MB Display Settings"
be_bb_color = input.color(color.new(color.red, 70), "Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_border_color = input.color(color.red, "Border Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_text_color = input.color(color.red, "Text Color", group=be_bb_display_settings, inline=be_bb_inline_color)


var float[] high_points_arr = array.new_float(5)
var int[] high_index_arr = array.new_int(5)
var float[] low_points_arr = array.new_float(5)
var int[] low_index_arr = array.new_int(5)

var box[] bu_ob_boxes = array.new_box(5)
var box[] be_ob_boxes = array.new_box(5)
var box[] bu_bb_boxes = array.new_box(5)
var box[] be_bb_boxes = array.new_box(5)

to_up = high >= ta.highest(zigzag_len)
to_down = low <= ta.lowest(zigzag_len)

trend = 1
trend := nz(trend[1], 1)
trend := trend == 1 and to_down ? -1 : trend == -1 and to_up ? 1 : trend

last_trend_up_since = ta.barssince(to_up[1])
low_val = ta.lowest(nz(last_trend_up_since > 0 ? last_trend_up_since : 1, 1))
low_index = bar_index - ta.barssince(low_val == low)

last_trend_down_since = ta.barssince(to_down[1])
high_val = ta.highest(nz(last_trend_down_since > 0 ? last_trend_down_since : 1, 1))
high_index = bar_index - ta.barssince(high_val == high)

if ta.change(trend) != 0
    if trend == 1
        array.push(low_points_arr, low_val)
        array.push(low_index_arr, low_index)
    if trend == -1
        array.push(high_points_arr, high_val)
        array.push(high_index_arr, high_index)


f_get_high(ind) =>
    [array.get(high_points_arr, array.size(high_points_arr) - 1 - ind), array.get(high_index_arr, array.size(high_index_arr) - 1 - ind)]


f_get_low(ind) =>
    [array.get(low_points_arr, array.size(low_points_arr) - 1 - ind), array.get(low_index_arr, array.size(low_index_arr) - 1 - ind)]


f_delete_box(box_arr) =>
    if delete_boxes
        box.delete(array.shift(box_arr))
    else
        array.shift(box_arr)
    0


[h0, h0i] = f_get_high(0)
[h1, h1i] = f_get_high(1)

[l0, l0i] = f_get_low(0)
[l1, l1i] = f_get_low(1)

if ta.change(trend) != 0 and show_zigzag
    if trend == 1
        line.new(h0i, h0, l0i, l0)
    if trend == -1
        line.new(l0i, l0, h0i, h0)

market = 1
market := nz(market[1], 1)
// market := market == 1 and close < l0 and low < l0 - math.abs(h0 - l0) * fib_factor ? -1 : market == -1 and close > h0 and high > h0 + math.abs(h0 - l0) * fib_factor ? 1 : market
last_l0 = ta.valuewhen(ta.change(market) != 0, l0, 0)
last_h0 = ta.valuewhen(ta.change(market) != 0, h0, 0)
market := last_l0 == l0 or last_h0 == h0 ? market : market == 1 and l0 < l1 and l0 < l1 - math.abs(h0 - l1) * fib_factor ? -1 : market == -1 and h0 > h1 and h0 > h1 + math.abs(h1 - l0) * fib_factor ? 1 : market

bu_ob_index = bar_index
bu_ob_index := nz(bu_ob_index[1], bar_index)
for i=h1i to l0i[zigzag_len]
    index = bar_index - i 
    if open[index] > close[index]
        bu_ob_index := bar_index[index]

bu_ob_since = bar_index - bu_ob_index

be_ob_index = bar_index
be_ob_index := nz(be_ob_index[1], bar_index)
for i=l1i to h0i[zigzag_len]
    index = bar_index - i 
    if open[index] < close[index]
        be_ob_index := bar_index[index]

be_ob_since = bar_index - be_ob_index

be_bb_index = bar_index
be_bb_index := nz(be_bb_index[1], bar_index)
for i=h1i - zigzag_len to l1i
    index = bar_index - i
    if open[index] > close[index]
        be_bb_index := bar_index[index]

be_bb_since = bar_index - be_bb_index

bu_bb_index = bar_index
bu_bb_index := nz(bu_bb_index[1], bar_index)
for i=l1i - zigzag_len to h1i
    index = bar_index - i
    if open[index] < close[index]
        bu_bb_index := bar_index[index]

bu_bb_since = bar_index - bu_bb_index

if ta.change(market) != 0
    if market == 1
        line.new(h1i, h1, h0i, h1, color=color.green, width=2)
        label.new(int(math.avg(h1i, l0i)), h1, "MSB", color=color.new(color.black, 100), style=label.style_label_down, textcolor=color.green, size=size.small)
        bu_ob = box.new(bu_ob_index, high[bu_ob_since], bar_index + 10, low[bu_ob_since], bgcolor=bu_ob_color, border_color=bu_ob_border_color, text="Bu-OB", text_color=bu_ob_text_color, text_halign=text.align_right, text_size=text_size)
        bu_bb = box.new(bu_bb_index, high[bu_bb_since], bar_index + 10, low[bu_bb_since], bgcolor=bu_bb_color, border_color=bu_bb_border_color, text=l0 < l1 ? "Bu-BB" : "Bu-MB", text_color=bu_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(bu_ob_boxes, bu_ob)
        array.push(bu_bb_boxes, bu_bb)
    if market == -1
        line.new(l1i, l1, l0i, l1, color=color.red, width=2)
        label.new(int(math.avg(l1i, h0i)), l1, "MSB", color=color.new(color.black, 100), style=label.style_label_up, textcolor=color.red, size=size.small)
        be_ob = box.new(be_ob_index, high[be_ob_since], bar_index + 10, low[be_ob_since], bgcolor=be_ob_color, border_color=be_ob_border_color, text="Be-OB", text_color=be_ob_text_color, text_halign=text.align_right, text_size=text_size)
        be_bb = box.new(be_bb_index, high[be_bb_since], bar_index + 10, low[be_bb_since], bgcolor=be_bb_color, border_color=be_bb_border_color, text=h0 > h1 ? "Be-BB" : "Be-MB", text_color=be_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(be_ob_boxes, be_ob)
        array.push(be_bb_boxes, be_bb)

for bull_ob in bu_ob_boxes
    bottom = box.get_bottom(bull_ob)
    top = box.get_top(bull_ob)
    if close < bottom
        f_delete_box(bu_ob_boxes)
    else if close < top
        alert("Price in the BU-OB zone")
    else
        box.set_right(bull_ob, bar_index + 10)
    
for bear_ob in be_ob_boxes
    top = box.get_top(bear_ob)
    bottom = box.get_bottom((bear_ob))
    if close > top
        f_delete_box(be_ob_boxes)
    if close > bottom
        alert("Price in the BE-OB zone")
    else
        box.set_right(bear_ob, bar_index + 10)
        
for bear_bb in be_bb_boxes
    top = box.get_top(bear_bb)
    bottom = box.get_bottom(bear_bb)
    if close > top
        f_delete_box(be_bb_boxes)
    else if close > bottom
        alert("Price in the BE-BB zone")
    else
        box.set_right(bear_bb, bar_index + 10)
        
for bull_bb in bu_bb_boxes
    bottom = box.get_bottom(bull_bb)
    top = box.get_top(bull_bb)
    if close < bottom
        f_delete_box(bu_bb_boxes)
    else if close < top
        alert("Price in the BU-BB zone")
    else
        box.set_right(bull_bb, bar_index + 10)


alertcondition(ta.change(market) != 0, "MSB", "MSB")



//** Supertrend **//

Periods = input(title='ATR Period', defval=10)
src4 = input(hl2, title='Source')
Multiplier = input.float(title='ATR Multiplier', step=0.1, defval=3.0)
changeATR = input(title='Change ATR Calculation Method ?', defval=true)
showsignals = input(title='Show Buy/Sell Signals ?', defval=true)
highlighting = input(title='Highlighter On/Off ?', defval=true)
atr2 = ta.sma(ta.tr, Periods)
atr = changeATR ? ta.atr(Periods) : atr2
up = src4 - Multiplier * atr
up1 = nz(up[1], up)
up := close[1] > up1 ? math.max(up, up1) : up
dn = src4 + Multiplier * atr
dn1 = nz(dn[1], dn)
dn := close[1] < dn1 ? math.min(dn, dn1) : dn
trendl = 1
trendl := nz(trendl[1], trendl)
trendl := trendl == -1 and close > dn1 ? 1 : trendl == 1 and close < up1 ? -1 : trendl
upPlot = plot(trendl == 1 ? up : na, title='Up trendl', style=plot.style_linebr, linewidth=2, color=color.new(color.green, 0))
buySignal = trendl == 1 and trendl[1] == -1
plotshape(buySignal ? up : na, title='Uptrendl Begins', location=location.absolute, style=shape.circle, size=size.tiny, color=color.new(color.green, 0))
plotshape(buySignal and showsignals ? up : na, title='Buy', text='Buy', location=location.absolute, style=shape.labelup, size=size.tiny, color=color.new(color.green, 0), textcolor=color.new(color.white, 0))
dnPlot = plot(trendl == 1 ? na : dn, title='Down trendl', style=plot.style_linebr, linewidth=2, color=color.new(color.red, 0))
sellSignal = trendl == -1 and trendl[1] == 1
plotshape(sellSignal ? dn : na, title='Downtrendl Begins', location=location.absolute, style=shape.circle, size=size.tiny, color=color.new(color.red, 0))
plotshape(sellSignal and showsignals ? dn : na, title='Sell', text='Sell', location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.new(color.red, 0), textcolor=color.new(color.white, 0))
mPlot = plot(ohlc4, title='', style=plot.style_circles, linewidth=0)
longFillColor = highlighting ? trendl == 1 ? color.green : color.white : color.white
shortFillColor = highlighting ? trendl == -1 ? color.red : color.white : color.white
fill(mPlot, upPlot, title='Uptrendl Highligter', color=longFillColor, transp=90)
fill(mPlot, dnPlot, title='Downtrendl Highligter', color=shortFillColor, transp=90)
alertcondition(buySignal, title='Supertrendl Buy', message='Supertrendl Buy!')
alertcondition(sellSignal, title='Supertrendl Sell', message='Supertrendl Sell!')
changeCond = trendl != trendl[1]
alertcondition(changeCond, title='Supertrendl Direction Change', message='Supertrendl has changed direction!')

//** Volume based SR zone **//

// Inputs
ExtendLines1 = input.bool(title='Extend all S/R Zones to Next Zone', defval=true, inline='extline', group='*** General Settings ***')
ext_active = input.bool(title='Extend active S/R Zones to Right', defval=true, inline='extline', group='*** General Settings ***')
ShowLabel = input.bool(title='Show Time Frame Label?', defval=true, group='*** General Settings ***')
label_loc = input.string(title='Label Location', defval='Right', options=['Left', 'Right'], inline='1', group='*** General Settings ***')
label_offset = input.int(title='  Right Label Offset', defval=15, inline='1', tooltip='Adjust how far to the right you\'d like the time frame label to appear.', group='*** General Settings ***')
show_HL = input.bool(title='Show High/Low Line     ', defval=true, inline='1b', group='*** General Settings ***')
show_close = input.bool(title='Show Open/Close Line', defval=true, inline='1b', group='*** General Settings ***')
LineStyleHLInput = input.string(title='Line Style (H/L)', defval='Solid', options=['Solid', 'Dotted', 'Dashed'], inline='2', group='*** General Settings ***')
LineWidthHLInput = input.int(title='  Line Width (H/L)', defval=1, inline='2', group='*** General Settings ***')
LineStyleCloseInput = input.string(title='Line Style (O/C)', defval='Solid', options=['Solid', 'Dotted', 'Dashed'], inline='3', group='*** General Settings ***')
LineWidthCloseInput = input.int(title='  Line Width (O/C)', defval=1, inline='3', group='*** General Settings ***')

var string LineStyleHL = na

LineStyleHL := if LineStyleHLInput == 'Solid'
    line.style_solid
else if LineStyleHLInput == 'Dotted'
    line.style_dotted
else if LineStyleHLInput == 'Dashed'
    line.style_dashed

var string LineStyleClose = na

LineStyleClose := if LineStyleCloseInput == 'Solid'
    line.style_solid
else if LineStyleCloseInput == 'Dotted'
    line.style_dotted
else if LineStyleCloseInput == 'Dashed'
    line.style_dashed

// Time Frame 1 = TF1
TF1_Menu = input.string(title='Display Lines Only, With Zones, or Disable     ', defval='S/R Zones', options=['S/R', 'S/R Zones', 'Disable'], group='*** Time Frame 1 ***')
TF1_input = input.string(title='Time Frame 1', defval='Chart', options=['Chart', '1m', '3m', '5m', '15m', '30m', '45m', '1h', '2h', '3h', '4h', '6h', '8h', '12h', 'D', '3D', 'W', '2W', '1M', '12M'], group='*** Time Frame 1 ***')
TF1_VolMA1Input = input.int(title='Volume MA - Threshold', defval=6, group='*** Time Frame 1 ***')
TF1_NumZones = input.int(title='Number of Zones Back', defval=30, minval=1, maxval=100, group='*** Time Frame 1 ***',
 tooltip='Change how many zones back you would like on the chart for time frame 1 (this number applies to both # of support zones and # of resistance zones back). Be mindful of setting too high with other zones, as the maximum total lines allowed on the chart is 500.')
TF1_extRight = input.bool(title='Extend S/R Zones to Right', defval=false, group='*** Time Frame 1 ***')
TF1_ResLinesColor = input.color(color.new(color.red, 20), 'Resistance Lines Color', inline='1', group='*** Time Frame 1 ***')
TF1_ResZoneColor = input.color(color.new(color.red, 90), 'Resistance Zone Color', inline='2', group='*** Time Frame 1 ***')
TF1_SupLinesColor = input.color(color.new(color.lime, 20), '        Support Lines Color', inline='1', group='*** Time Frame 1 ***')
TF1_SupZoneColor = input.color(color.new(color.lime, 90), '         Support Zone Color', inline='2', group='*** Time Frame 1 ***')
TF1_Alerts = input.string(title='Alerts', defval='None', 
  options=['None', 'Price Enters Resistance Zone', 'Price Enters Support Zone', 'Price Enters Either S/R Zone', 'Price Breaks Up Resistance', 'Price Breaks Down Support', 'Price Breaks Either S/R', 'New S/R Zone Found', 'All Alerts On'], 
  tooltip='Select the type of alert you would like, then save settings. On chart, right click on SR indicator and click \'Add Alert\' then save. If you would like to change the alert, delete existing alert, change alert settings on indicator, then create new alert', 
  group='*** Time Frame 1 ***')

// Time Frame 2 = TF2
TF2_Menu = input.string(title='Display Lines Only, With Zones, or Disable     ', defval='S/R Zones', options=['S/R', 'S/R Zones', 'Disable'], group='*** Time Frame 2 ***')
TF2_input = input.string(title='Time Frame 2', defval='4h', options=['1m', '3m', '5m', '15m', '30m', '45m', '1h', '2h', '3h', '4h', '6h', '8h', '12h', 'D', '3D', 'W', '2W', '1M', '12M'], group='*** Time Frame 2 ***')
TF2_VolMA1Input = input.int(title='Volume MA - Threshold', defval=6, group='*** Time Frame 2 ***')
TF2_NumZones = input.int(title='Number of Zones Back', defval=30, minval=1, maxval=100, group='*** Time Frame 2 ***',
 tooltip='Change how many zones back you would like on the chart for time frame 2 (this number applies to both # of support zones and # of resistance zones back). Be mindful of setting too high with other zones, as the maximum total lines allowed on the chart is 500.')
TF2_extRight = input.bool(title='Extend S/R Zones to Right', defval=false, group='*** Time Frame 2 ***')
TF2_ResLinesColor = input.color(color.new(color.fuchsia, 20), 'Resistance Lines Color', inline='1', group='*** Time Frame 2 ***')
TF2_ResZoneColor = input.color(color.new(color.fuchsia, 90), 'Resistance Zone Color', inline='2', group='*** Time Frame 2 ***')
TF2_SupLinesColor = input.color(color.new(color.green, 20), '        Support Lines Color', inline='1', group='*** Time Frame 2 ***')
TF2_SupZoneColor = input.color(color.new(color.green, 90), '         Support Zone Color', inline='2', group='*** Time Frame 2 ***')
TF2_Alerts = input.string(title='Alerts', defval='None', 
  options=['None', 'Price Enters Resistance Zone', 'Price Enters Support Zone', 'Price Enters Either S/R Zone', 'Price Breaks Up Resistance', 'Price Breaks Down Support', 'Price Breaks Either S/R', 'New S/R Zone Found', 'All Alerts On'], 
  tooltip='Select the type of alert you would like, then save settings. On chart, right click on SR indicator and click \'Add Alert\' then save. If you would like to change the alert, delete existing alert, change alert settings on indicator, then create new alert', 
  group='*** Time Frame 2 ***')

// Time Frame 3 = TF3
TF3_Menu = input.string(title='Display Lines Only, With Zones, or Disable     ', defval='S/R Zones', options=['S/R', 'S/R Zones', 'Disable'], group='*** Time Frame 3 ***')
TF3_input = input.string(title='Time Frame 3', defval='D', options=['1m', '3m', '5m', '15m', '30m', '45m', '1h', '2h', '3h', '4h', '6h', '8h', '12h', 'D', '3D', 'W', '2W', '1M', '12M'], group='*** Time Frame 3 ***')
TF3_VolMA1Input = input.int(title='Volume MA - Threshold', defval=6, group='*** Time Frame 3 ***')
TF3_NumZones = input.int(title='Number of Zones Back', defval=30, minval=1, maxval=100, group='*** Time Frame 3 ***',
 tooltip='Change how many zones back you would like on the chart for time frame 3 (this number applies to both # of support zones and # of resistance zones back). Be mindful of setting too high with other zones, as the maximum total lines allowed on the chart is 500.')
TF3_extRight = input.bool(title='Extend S/R Zones to Right', defval=false, group='*** Time Frame 3 ***')
TF3_ResLinesColor = input.color(color.new(color.orange, 20), 'Resistance Lines Color', inline='1', group='*** Time Frame 3 ***')
TF3_ResZoneColor = input.color(color.new(color.orange, 90), 'Resistance Zone Color', inline='2', group='*** Time Frame 3 ***')
TF3_SupLinesColor = input.color(color.new(color.blue, 20), '        Support Lines Color', inline='1', group='*** Time Frame 3 ***')
TF3_SupZoneColor = input.color(color.new(color.blue, 90), '         Support Zone Color', inline='2', group='*** Time Frame 3 ***')
TF3_Alerts = input.string(title='Alerts', defval='None', 
  options=['None', 'Price Enters Resistance Zone', 'Price Enters Support Zone', 'Price Enters Either S/R Zone', 'Price Breaks Up Resistance', 'Price Breaks Down Support', 'Price Breaks Either S/R', 'New S/R Zone Found', 'All Alerts On'], 
  tooltip='Select the type of alert you would like, then save settings. On chart, right click on SR indicator and click \'Add Alert\' then save. If you would like to change the alert, delete existing alert, change alert settings on indicator, then create new alert', 
  group='*** Time Frame 3 ***')

// Time Frame 4 = TF4
TF4_Menu = input.string(title='Display Lines Only, With Zones, or Disable     ', defval='S/R Zones', options=['S/R', 'S/R Zones', 'Disable'], group='*** Time Frame 4 ***')
TF4_input = input.string(title='Time Frame 4', defval='W', options=['1m', '3m', '5m', '15m', '30m', '45m', '1h', '2h', '3h', '4h', '6h', '8h', '12h', 'D', '3D', 'W', '2W', '1M', '12M'], group='*** Time Frame 4 ***')
TF4_VolMA1Input = input.int(title='Volume MA - Threshold', defval=6, group='*** Time Frame 4 ***')
TF4_NumZones = input.int(title='Number of Zones Back', defval=30, minval=1, maxval=100, group='*** Time Frame 4 ***',
 tooltip='Change how many zones back you would like on the chart for time frame 4 (this number applies to both # of support zones and # of resistance zones back). Be mindful of setting too high with other zones, as the maximum total lines allowed on the chart is 500.')
TF4_extRight = input.bool(title='Extend S/R Zones to Right', defval=false, group='*** Time Frame 4 ***')
TF4_ResLinesColor = input.color(color.new(color.maroon, 20), 'Resistance Lines Color', inline='1', group='*** Time Frame 4 ***')
TF4_ResZoneColor = input.color(color.new(color.maroon, 90), 'Resistance Zone Color', inline='2', group='*** Time Frame 4 ***')
TF4_SupLinesColor = input.color(color.new(color.teal, 20), '        Support Lines Color', inline='1', group='*** Time Frame 4 ***')
TF4_SupZoneColor = input.color(color.new(color.teal, 90), '         Support Zone Color', inline='2', group='*** Time Frame 4 ***')
TF4_Alerts = input.string(title='Alerts', defval='None', 
  options=['None', 'Price Enters Resistance Zone', 'Price Enters Support Zone', 'Price Enters Either S/R Zone', 'Price Breaks Up Resistance', 'Price Breaks Down Support', 'Price Breaks Either S/R', 'New S/R Zone Found', 'All Alerts On'],
  tooltip='Select the type of alert you would like, then save settings. On chart, right click on SR indicator and click \'Add Alert\' then save. If you would like to change the alert, delete existing alert, change alert settings on indicator, then create new alert', 
  group='*** Time Frame 4 ***')

f_TFx(_TF_input) =>
    if _TF_input == 'Chart'
        timeframe.period
    else if _TF_input == '1m'
        '1'
    else if _TF_input == '3m'
        '3'
    else if _TF_input == '5m'
        '5'
    else if _TF_input == '15m'
        '15'
    else if _TF_input == '30m'
        '30'
    else if _TF_input == '45m'
        '45'
    else if _TF_input == '1h'
        '60'
    else if _TF_input == '2h'
        '120'
    else if _TF_input == '3h'
        '180'
    else if _TF_input == '4h'
        '240'
    else if _TF_input == '6h'
        '360'
    else if _TF_input == '8h'
        '480'
    else if _TF_input == '12h'
        '720'
    else if _TF_input == 'D'
        'D'
    else if _TF_input == '3D'
        '3D'
    else if _TF_input == 'W'
        'W'
    else if _TF_input == '2W'
        '2W'
    else if _TF_input == '1M'
        '1M'
    else if _TF_input == '12M'
        '12M'  

TF1 = f_TFx(TF1_input)
TF2 = f_TFx(TF2_input)
TF3 = f_TFx(TF3_input)
TF4 = f_TFx(TF4_input)

vol_check = na(volume) or volume[1]==0
var table vol_check_table = na
if barstate.islast and vol_check
    table.delete(vol_check_table)
    vol_check_table := table.new(position=position.middle_right, columns=1, rows=1, frame_color=color.red, frame_width=1)
    table.cell(vol_check_table, column=0, row=0, text='There is no volume data for this symbol' + ' (' + syminfo.tickerid + ')' + '\n Please use a different symbol with volume data', text_color=color.red)

// // --------- This ensures that no plots from lower time frames will be plotted on higher time frames.
// ————— Converts current chart resolution into a float minutes value.
f_resInMinutes() =>
    _resInMinutes = timeframe.multiplier * (timeframe.isseconds ? 1. / 60 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : na)
    _resInMinutes
// ————— Returns the float minutes value of the string _res.
f_tfResInMinutes(_res) =>
    // _res: resolution of any TF (in "timeframe.period" string format).
    // Dependency: f_resInMinutes().
    request.security(syminfo.tickerid, _res, f_resInMinutes())

// —————————— Determine if current timeframe is smaller that higher timeframe selected in Inputs.
// Get higher timeframe in minutes.
TF1InMinutes = f_tfResInMinutes(TF1)
TF2InMinutes = f_tfResInMinutes(TF2)
TF3InMinutes = f_tfResInMinutes(TF3)
TF4InMinutes = f_tfResInMinutes(TF4)

// Get current timeframe in minutes.
currentTFInMinutes = f_resInMinutes()
// Compare current TF to higher TF to make sure it is smaller, otherwise our plots don't make sense.
chartOnLowerTF1 = currentTFInMinutes <= TF1InMinutes
chartOnLowerTF2 = currentTFInMinutes <= TF2InMinutes
chartOnLowerTF3 = currentTFInMinutes <= TF3InMinutes
chartOnLowerTF4 = currentTFInMinutes <= TF4InMinutes

chartEqualTF2 = currentTFInMinutes == TF2InMinutes and TF2_Menu != 'Disable'
chartEqualTF3 = currentTFInMinutes == TF3InMinutes and TF3_Menu != 'Disable'
chartEqualTF4 = currentTFInMinutes == TF4InMinutes and TF4_Menu != 'Disable'

TF1_inH = str.tostring(TF1InMinutes / 60)
TF1_text = TF1InMinutes >= 60 and TF1InMinutes < 1440 ? TF1_inH + 'h' : TF1InMinutes < 60 ? TF1 + 'm' : TF1

//--- In order to get the left side of SR zone on higher time frames to line up directly on the bar with the fractal high or fractal low, we need to perform
//--- a series of calculations to find the pivot high/low. Since the FractalUp or FractalDown condition is found after 2 confirming bars, the SR zone would begin
//--- at the opening of the 3rd bar following the pivot high/low). For example, if there is a 4hr Fractal confirmed while on the 1hr chart, it would take 3 4hr bars to confirm. 
//--- That means the high/low point could've occured anywhere between 8-12 1hr bars ago.
// // --------- To get the correct bar_index for higher time frame SR zones placed on lower time frame candles, first the range of candles to scan needs to be established.
// // --------- Then find the highest/lowest bar within that range of bars for bar_index on the x1 (left) coordinates of lines (next steps below)
bool TF1_newbar = ta.change(time(TF1)) != 0, bool TF2_newbar = ta.change(time(TF2)) != 0, bool TF3_newbar = ta.change(time(TF3)) != 0, bool TF4_newbar = ta.change(time(TF4)) != 0 
TF1_bi1 = ta.valuewhen(TF1_newbar, bar_index, 1), TF2_bi1 = ta.valuewhen(TF2_newbar, bar_index, 1), TF3_bi1 = ta.valuewhen(TF3_newbar, bar_index, 1), TF4_bi1 = ta.valuewhen(TF4_newbar, bar_index, 1)
TF1_bi5 = ta.valuewhen(TF1_newbar, bar_index, 5), TF2_bi5 = ta.valuewhen(TF2_newbar, bar_index, 5), TF3_bi5 = ta.valuewhen(TF3_newbar, bar_index, 5), TF4_bi5 = ta.valuewhen(TF4_newbar, bar_index, 5)
TF1_bb1 = bar_index-TF1_bi1, TF2_bb1 = bar_index-TF2_bi1, TF3_bb1 = bar_index-TF3_bi1, TF4_bb1 = bar_index-TF4_bi1
TF1_bb5 = bar_index-TF1_bi5, TF2_bb5 = bar_index-TF2_bi5, TF3_bb5 = bar_index-TF3_bi5, TF4_bb5 = bar_index-TF4_bi5
TF1_br = TF1_bb5 - TF1_bb1, TF2_br = TF2_bb5 - TF2_bb1, TF3_br = TF3_bb5 - TF3_bb1, TF4_br = TF4_bb5 - TF4_bb1

// Get offset value for the highest high or lowest low found within the specified range , using [] to establish the starting point back to begin scanning past bars for highest high or lowest low. 
// Moving the starting point back ensures it scans within the range in which the high/low was found by FractalUp/FractalDown condition.
// Output by default is negative, make positive with absolute value for bar_index.
// Adding the TFx_bar_index back in accounts for the number of bars skipped back in [].
// First check if the number of bars back to scan for pivot high/low is going to be over the max bars back, and if so set the bar_index to the max bars back, 
// otherwise get exact bar index value for pivot high/low.

var int TF1_Hi_Bi = na
var int TF1_Lo_Bi = na
var int TF2_Hi_Bi = na
var int TF2_Lo_Bi = na
var int TF3_Hi_Bi = na
var int TF3_Lo_Bi = na
var int TF4_Hi_Bi = na
var int TF4_Lo_Bi = na

if TF1_bb1 > 4999 or (TF1_bb1 + TF1_br) > 4999
    TF1_Hi_Bi := 4999
    TF1_Lo_Bi := 4999
else
    TF1_Hi_Bi := math.abs(ta.highestbars(high, nz(TF1_br, 1)))[TF1_bb1] + TF1_bb1
    TF1_Lo_Bi := math.abs(ta.lowestbars(low, nz(TF1_br, 1)))[TF1_bb1] + TF1_bb1

if TF2_bb1 > 4999 or (TF2_bb1 + TF2_br) > 4999
    TF2_Hi_Bi := 4999
    TF2_Lo_Bi := 4999
else
    TF2_Hi_Bi := math.abs(ta.highestbars(high, nz(TF2_br, 1)))[TF2_bb1] + TF2_bb1
    TF2_Lo_Bi := math.abs(ta.lowestbars(low, nz(TF2_br, 1)))[TF2_bb1] + TF2_bb1

if TF3_bb1 > 4999 or (TF3_bb1 + TF3_br) > 4999
    TF3_Hi_Bi := 4999
    TF3_Lo_Bi := 4999
else
    TF3_Hi_Bi := math.abs(ta.highestbars(high, nz(TF3_br, 1)))[TF3_bb1] + TF3_bb1
    TF3_Lo_Bi := math.abs(ta.lowestbars(low, nz(TF3_br, 1)))[TF3_bb1] + TF3_bb1

if TF4_bb1 > 4999 or (TF4_bb1 + TF4_br) > 4999
    TF4_Hi_Bi := 4999
    TF4_Lo_Bi := 4999
else
    TF4_Hi_Bi := math.abs(ta.highestbars(high, nz(TF4_br, 1)))[TF4_bb1] + TF4_bb1
    TF4_Lo_Bi := math.abs(ta.lowestbars(low, nz(TF4_br, 1)))[TF4_bb1] + TF4_bb1


// TFUp and TFDown Calculations
f_tfUp(_TF_High, _TF_Vol, _TF_VolMA) =>
    _TF_High[3] > _TF_High[4] and _TF_High[4] > _TF_High[5] and _TF_High[2] < _TF_High[3] and _TF_High[1] < _TF_High[2] and _TF_Vol[3] > _TF_VolMA[3]
f_tfDown(_TF_Low, _TF_Vol, _TF_VolMA) =>
    _TF_Low[3] < _TF_Low[4] and _TF_Low[4] < _TF_Low[5] and _TF_Low[2] > _TF_Low[3] and _TF_Low[1] > _TF_Low[2] and _TF_Vol[3] > _TF_VolMA[3]

// Function for each time frame's various sources used in FractalUp and FractalDown calculations.
f_tfSources(_res, _source) =>
    request.security(syminfo.tickerid, _res, _source)

// Line and label arrays
var TF1_UpperSupportLine_array = array.new_line(TF1_NumZones), var TF2_UpperSupportLine_array = array.new_line(TF2_NumZones), var TF3_UpperSupportLine_array = array.new_line(TF3_NumZones), var TF4_UpperSupportLine_array = array.new_line(TF4_NumZones)
var TF1_LowerSupportLine_array = array.new_line(TF1_NumZones), var TF2_LowerSupportLine_array = array.new_line(TF2_NumZones), var TF3_LowerSupportLine_array = array.new_line(TF3_NumZones), var TF4_LowerSupportLine_array = array.new_line(TF4_NumZones)
var TF1SupLabel_array = array.new_label(1), var TF2SupLabel_array = array.new_label(1), var TF3SupLabel_array = array.new_label(1), var TF4SupLabel_array = array.new_label(1)

var TF1_UpperResLine_array = array.new_line(TF1_NumZones), var TF2_UpperResLine_array = array.new_line(TF2_NumZones), var TF3_UpperResLine_array = array.new_line(TF3_NumZones), var TF4_UpperResLine_array = array.new_line(TF4_NumZones)
var TF1_LowerResLine_array = array.new_line(TF1_NumZones), var TF2_LowerResLine_array = array.new_line(TF2_NumZones), var TF3_LowerResLine_array = array.new_line(TF3_NumZones), var TF4_LowerResLine_array = array.new_line(TF4_NumZones)
var TF1ResLabel_array = array.new_label(1), var TF2ResLabel_array = array.new_label(1), var TF3ResLabel_array = array.new_label(1), var TF4ResLabel_array = array.new_label(1)

// Resistance Line Functions
TF_ResistanceLineA(TF_input,TF_FractalUp,TF_ResLineColor,TF_UpperResLine_array,TF_NumZones,TF_ResZone, TF_LowerResLine_array,TF_text,TF_ResLabel_array,bi_hi,bi_3,bi,bi_2,ext_right) =>
    if show_HL
        UpperResistanceLine = line.new(x1=TF_input != 'Chart' ? bi_hi : bi_3, y1=TF_FractalUp, x2=bi, y2=TF_FractalUp, color=TF_ResLineColor, style=LineStyleHL, width=LineWidthHLInput, extend=extend.right)
        line.set_extend(id=array.get(TF_UpperResLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_UpperResLine_array, TF_NumZones-1), x=TF_input != 'Chart' ? bi_hi : bi_3)
        array.push(TF_UpperResLine_array, UpperResistanceLine)
        line.delete(array.shift(TF_UpperResLine_array))
    if show_close
        LowerResistanceLine = line.new(x1=TF_input != 'Chart' ? bi_hi : bi_3, y1=TF_ResZone, x2=bi, y2=TF_ResZone, color=TF_ResLineColor, style=LineStyleClose, width=LineWidthCloseInput, extend=extend.right)
        line.set_extend(id=array.get(TF_LowerResLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_LowerResLine_array, TF_NumZones-1), x=TF_input != 'Chart' ? bi_hi : bi_3)
        array.push(TF_LowerResLine_array, LowerResistanceLine)
        line.delete(array.shift(TF_LowerResLine_array))
    if ShowLabel == true and label_loc == 'Left'
        TFResLabel = label.new(TF_input != 'Chart' ? bi_hi : bi_2, TF_FractalUp, text=TF_text + "(R)", color=color.new(color.white, 100), size=size.normal, style=label.style_label_right, textcolor=TF_ResLineColor)
        array.push(TF_ResLabel_array, TFResLabel)
        label.delete(array.shift(TF_ResLabel_array))

TF_ResistanceLineB(TF_FractalUp,TF_ResLineColor,TF_UpperResLine_array,TF_NumZones,TF_ResZone,TF_LowerResLine_array,TF_text,TF_ResLabel_array,bi3,bi,ext_right) =>
    if show_HL
        UpperResistanceLine = line.new(x1=bi3, y1=TF_FractalUp, x2=bi, y2=TF_FractalUp, color=TF_ResLineColor, style=LineStyleHL, width=LineWidthHLInput, extend=extend.right)
        line.set_extend(id=array.get(TF_UpperResLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_UpperResLine_array, TF_NumZones-1), x=bi3)
        array.push(TF_UpperResLine_array, UpperResistanceLine)
        line.delete(array.shift(TF_UpperResLine_array))
    if show_close
        LowerResistanceLine = line.new(x1=bi3, y1=TF_ResZone, x2=bi, y2=TF_ResZone, color=TF_ResLineColor, style=LineStyleClose, width=LineWidthCloseInput, extend=extend.right)
        line.set_extend(id=array.get(TF_LowerResLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_LowerResLine_array, TF_NumZones-1), x=bi3)
        array.push(TF_LowerResLine_array, LowerResistanceLine)
        line.delete(array.shift(TF_LowerResLine_array))
    if ShowLabel == true and label_loc == 'Left'
        TFResLabel = label.new(bi3, TF_FractalUp, text=TF_text + "(R)", color=color.new(color.white, 100), size=size.normal, style=label.style_label_right, textcolor=TF_ResLineColor)
        array.push(TF_ResLabel_array, TFResLabel)
        label.delete(array.shift(TF_ResLabel_array))

// Support Line Functions
TF_SupportLineA(TF_input, TF_FractalDown,TF_SupLinesColor,TF_UpperSupportLine_array,TF_NumZones,TF_SupportZone, TF_LowerSupportLine_array,TF_text,TF_SupLabel_array,bi_lo,bi_3,bi,bi_2,ext_right) =>
    if show_close
        UpperSupportLine = line.new(x1=TF_input != 'Chart' ? bi_lo : bi_3, y1=TF_SupportZone, x2=bi, y2=TF_SupportZone, color=TF_SupLinesColor, style=LineStyleClose, width=LineWidthCloseInput, extend=extend.right)
        line.set_extend(id=array.get(TF_UpperSupportLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_UpperSupportLine_array, TF_NumZones-1), x=TF_input != 'Chart' ? bi_lo : bi_3)
        array.push(TF_UpperSupportLine_array, UpperSupportLine)
        line.delete(array.shift(TF_UpperSupportLine_array))
    if show_HL
        LowerSupportLine = line.new(x1=TF_input != 'Chart' ? bi_lo : bi_3, y1=TF_FractalDown, x2=bi, y2=TF_FractalDown, color=TF_SupLinesColor, style=LineStyleHL, width=LineWidthHLInput, extend=extend.right)
        line.set_extend(id=array.get(TF_LowerSupportLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_LowerSupportLine_array, TF_NumZones-1), x=TF_input != 'Chart' ? bi_lo : bi_3)
        array.push(TF_LowerSupportLine_array, LowerSupportLine)
        line.delete(array.shift(TF_LowerSupportLine_array))
    if ShowLabel == true and label_loc == 'Left'
        SupLabel = label.new(TF_input != 'Chart' ? bi_lo : bi_2, TF_FractalDown, text=TF_text + "(S)", color=color.new(color.white, 100), size=size.normal, style=label.style_label_right, textcolor=TF_SupLinesColor)
        array.push(TF_SupLabel_array, SupLabel)
        label.delete(array.shift(TF_SupLabel_array))

TF_SupportLineB(TF_FractalDown,TF_SupLinesColor,TF_UpperSupportLine_array,TF_NumZones,TF_SupportZone,TF_LowerSupportLine_array,TF_text,TF_SupLabel_array,bi3,bi,ext_right) =>
    if show_close
        UpperSupportLine = line.new(x1=bi3, y1=TF_SupportZone, x2=bi, y2=TF_SupportZone, color=TF_SupLinesColor, style=LineStyleClose, width=LineWidthCloseInput, extend=extend.right)
        line.set_extend(id=array.get(TF_UpperSupportLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_UpperSupportLine_array, TF_NumZones-1), x=bi3)
        array.push(TF_UpperSupportLine_array, UpperSupportLine)
        line.delete(array.shift(TF_UpperSupportLine_array))
    if show_HL
        LowerSupportLine = line.new(x1=bi3, y1=TF_FractalDown, x2=bi, y2=TF_FractalDown, color=TF_SupLinesColor, style=LineStyleHL, width=LineWidthHLInput, extend=extend.right)
        line.set_extend(id=array.get(TF_LowerSupportLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_LowerSupportLine_array, TF_NumZones-1), x=bi3)
        array.push(TF_LowerSupportLine_array, LowerSupportLine)
        line.delete(array.shift(TF_LowerSupportLine_array))
    if ShowLabel == true and label_loc == 'Left'
        SupLabel = label.new(bi3, TF_FractalDown, text=TF_text + "(S)", color=color.new(color.white, 100), size=size.normal, style=label.style_label_right, textcolor=TF_SupLinesColor)
        array.push(TF_SupLabel_array, SupLabel)
        label.delete(array.shift(TF_SupLabel_array))

// Label Function
TFLabel(bi, TF_Fractal, txt, txtcolor, TFLabel_array) =>
    Label = label.new(bi, TF_Fractal, text=txt, size=size.normal, style=label.style_none, textcolor=txtcolor)
    array.push(TFLabel_array, Label)
    label.delete(array.shift(TFLabel_array))

// S/R  = Time Frame 1 = TF1
TF1_Vol = f_tfSources(TF1, volume)
TF1_VolMA = ta.sma(TF1_Vol, TF1_VolMA1Input)
TF1_High = f_tfSources(TF1, high)
TF1_Low = f_tfSources(TF1, low)
TF1_Open = f_tfSources(TF1, open)
TF1_Close = f_tfSources(TF1, close)

TF1_Up = f_tfUp(TF1_High, TF1_Vol, TF1_VolMA)
TF1_Down = f_tfDown(TF1_Low, TF1_Vol, TF1_VolMA)

TF1_CalcFractalUp() =>
    TF1_FractalUp = 0.0
    TF1_FractalUp := TF1_Up ? TF1_High[3] : TF1_FractalUp[1]
    TF1_FractalUp

TF1_CalcFractalDown() =>
    TF1_FractalDown = 0.0
    TF1_FractalDown := TF1_Down ? TF1_Low[3] : TF1_FractalDown[1]
    TF1_FractalDown

TF1_FractalUp = request.security(syminfo.tickerid, TF1, TF1_CalcFractalUp())
TF1_FractalDown = request.security(syminfo.tickerid, TF1, TF1_CalcFractalDown())

// Zones - Current Time Frame = Time Frame 1 = TF1
// Fractal Up Zones
TF1_CalcFractalUpZone() =>
    TF1_FractalUpZone = 0.0
    TF1_FractalUpZone := TF1_Up and TF1_Close[3] >= TF1_Open[3] ? TF1_Close[3] : TF1_Up and TF1_Close[3] < TF1_Open[3] ? TF1_Open[3] : TF1_FractalUpZone[1]
    TF1_FractalUpZone

TF1_FractalUpZone = request.security(syminfo.tickerid, TF1, TF1_CalcFractalUpZone())
TF1_ResZone = TF1_FractalUpZone

// Fractal Down Zones
TF1_CalcFractalDownZone() =>
    TF1_FractalDownZone = 0.0
    TF1_FractalDownZone := TF1_Down and TF1_Close[3] >= TF1_Open[3] ? TF1_Open[3] : TF1_Down and TF1_Close[3] < TF1_Open[3] ? TF1_Close[3] : TF1_FractalDownZone[1]
    TF1_FractalDownZone

TF1_FractalDownZone = request.security(syminfo.tickerid, TF1, TF1_CalcFractalDownZone())
TF1_SupportZone = TF1_FractalDownZone

// Time Frame 1 = TF1 Resistance
if (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and TF1_FractalUp != TF1_FractalUp[1] and chartOnLowerTF1 and not chartEqualTF2 and not chartEqualTF3 and not chartEqualTF4
    TF_ResistanceLineA(TF1_input,TF1_FractalUp,TF1_ResLinesColor,TF1_UpperResLine_array,TF1_NumZones,TF1_ResZone, TF1_LowerResLine_array,TF1_text,TF1ResLabel_array,bar_index[TF1_Hi_Bi], bar_index[3], bar_index,bar_index[2], TF1_extRight)
else if (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and na(TF1_FractalUp != TF1_FractalUp[1]) and chartOnLowerTF1 and na(ta.barssince(TF1_FractalUp != TF1_FractalUp[1])) and not chartEqualTF2 and not chartEqualTF3 and not chartEqualTF4
    TF_ResistanceLineB(TF1_FractalUp,TF1_ResLinesColor,TF1_UpperResLine_array,TF1_NumZones,TF1_ResZone,TF1_LowerResLine_array,TF1_text,TF1ResLabel_array,bar_index[3],bar_index, TF1_extRight)

if (TF1_Menu == 'S/R Zones')
    linefill.new(array.get(TF1_UpperResLine_array, TF1_NumZones-1), array.get(TF1_LowerResLine_array, TF1_NumZones-1), TF1_ResZoneColor)

if ShowLabel == true and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and not chartEqualTF2 and not chartEqualTF3 and not chartEqualTF4 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF1_FractalUp, TF1_text+"(R)", TF1_ResLinesColor, TF1ResLabel_array)


// Time Frame 1 = TF1 Support
if (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and TF1_FractalDown != TF1_FractalDown[1] and chartOnLowerTF1 and not chartEqualTF2 and not chartEqualTF3 and not chartEqualTF4
    TF_SupportLineA(TF1_input,TF1_FractalDown,TF1_SupLinesColor,TF1_UpperSupportLine_array,TF1_NumZones,TF1_SupportZone, TF1_LowerSupportLine_array,TF1_text,TF1SupLabel_array,bar_index[TF1_Lo_Bi], bar_index[3], bar_index,bar_index[2], TF1_extRight)
else if (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and na(TF1_FractalDown != TF1_FractalDown[1]) and chartOnLowerTF1 and na(ta.barssince(TF1_FractalDown != TF1_FractalDown[1])) and not chartEqualTF2 and not chartEqualTF3 and not chartEqualTF4
    TF_SupportLineB(TF1_FractalDown,TF1_SupLinesColor,TF1_UpperSupportLine_array,TF1_NumZones,TF1_SupportZone,TF1_LowerSupportLine_array,TF1_text,TF1SupLabel_array,bar_index[3],bar_index, TF1_extRight)

if (TF1_Menu == 'S/R Zones')
    linefill.new(array.get(TF1_UpperSupportLine_array, TF1_NumZones-1), array.get(TF1_LowerSupportLine_array, TF1_NumZones-1), TF1_SupZoneColor)

if ShowLabel == true and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and not chartEqualTF2 and not chartEqualTF3 and not chartEqualTF4 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF1_FractalDown, TF1_text+"(S)", TF1_SupLinesColor, TF1SupLabel_array)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF1_UpperResLine_array, TF1_NumZones-1), extend.none)
    line.set_x2(array.get(TF1_UpperResLine_array, TF1_NumZones-1), bar_index)
    line.set_extend(array.get(TF1_LowerResLine_array, TF1_NumZones-1), extend.none)
    line.set_x2(array.get(TF1_LowerResLine_array, TF1_NumZones-1), bar_index)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF1_UpperSupportLine_array, TF1_NumZones-1), extend.none)
    line.set_x2(array.get(TF1_UpperSupportLine_array, TF1_NumZones-1), bar_index)
    line.set_extend(array.get(TF1_LowerSupportLine_array, TF1_NumZones-1), extend.none)
    line.set_x2(array.get(TF1_LowerSupportLine_array, TF1_NumZones-1), bar_index)

// S/R  = Time Frame 2 = TF2
TF2_Vol = f_tfSources(TF2, volume)
TF2_VolMA = ta.sma(TF2_Vol, TF2_VolMA1Input)
TF2_High = f_tfSources(TF2, high)
TF2_Low = f_tfSources(TF2, low)
TF2_Open = f_tfSources(TF2, open)
TF2_Close = f_tfSources(TF2, close)

TF2_Up = f_tfUp(TF2_High, TF2_Vol, TF2_VolMA)
TF2_Down = f_tfDown(TF2_Low, TF2_Vol, TF2_VolMA)

TF2_CalcFractalUp() =>
    TF2_FractalUp = 0.0
    TF2_FractalUp := TF2_Up ? TF2_High[3] : TF2_FractalUp[1]
    TF2_FractalUp

TF2_CalcFractalDown() =>
    TF2_FractalDown = 0.0
    TF2_FractalDown := TF2_Down ? TF2_Low[3] : TF2_FractalDown[1]
    TF2_FractalDown

TF2_FractalUp = request.security(syminfo.tickerid, TF2, TF2_CalcFractalUp())
TF2_FractalDown = request.security(syminfo.tickerid, TF2, TF2_CalcFractalDown())

// Zones - Current Time Frame = Time Frame 2 = TF2
// Fractal Up Zones
TF2_CalcFractalUpZone() =>
    TF2_FractalUpZone = 0.0
    TF2_FractalUpZone := TF2_Up and TF2_Close[3] >= TF2_Open[3] ? TF2_Close[3] : TF2_Up and TF2_Close[3] < TF2_Open[3] ? TF2_Open[3] : TF2_FractalUpZone[1]
    TF2_FractalUpZone

TF2_FractalUpZone = request.security(syminfo.tickerid, TF2, TF2_CalcFractalUpZone())
TF2_ResZone = TF2_FractalUpZone

// Fractal Down Zones
TF2_CalcFractalDownZone() =>
    TF2_FractalDownZone = 0.0
    TF2_FractalDownZone := TF2_Down and TF2_Close[3] >= TF2_Open[3] ? TF2_Open[3] : TF2_Down and TF2_Close[3] < TF2_Open[3] ? TF2_Close[3] : TF2_FractalDownZone[1]
    TF2_FractalDownZone

TF2_FractalDownZone = request.security(syminfo.tickerid, TF2, TF2_CalcFractalDownZone())
TF2_SupportZone = TF2_FractalDownZone

// Time Frame 2 = TF2 Resistance
if (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and TF2_FractalUp != TF2_FractalUp[1] and chartOnLowerTF2
    TF_ResistanceLineA(TF2_input,TF2_FractalUp,TF2_ResLinesColor,TF2_UpperResLine_array,TF2_NumZones,TF2_ResZone, TF2_LowerResLine_array,TF2_input,TF2ResLabel_array,bar_index[TF2_Hi_Bi], bar_index[3], bar_index,bar_index[2], TF2_extRight)
else if (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and na(TF2_FractalUp != TF2_FractalUp[1]) and chartOnLowerTF2 and na(ta.barssince(TF2_FractalUp != TF2_FractalUp[1]))
    TF_ResistanceLineB(TF2_FractalUp,TF2_ResLinesColor,TF2_UpperResLine_array,TF2_NumZones,TF2_ResZone,TF2_LowerResLine_array,TF2_input,TF2ResLabel_array,bar_index[3],bar_index, TF2_extRight)

if (TF2_Menu == 'S/R Zones')
    linefill.new(array.get(TF2_UpperResLine_array, TF2_NumZones-1), array.get(TF2_LowerResLine_array, TF2_NumZones-1), TF2_ResZoneColor)

if ShowLabel == true and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF2_FractalUp, TF2_input+"(R)", TF2_ResLinesColor, TF2ResLabel_array)


// Time Frame 2 = TF2 Support
if (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and TF2_FractalDown != TF2_FractalDown[1] and chartOnLowerTF2
    TF_SupportLineA(TF2_input,TF2_FractalDown,TF2_SupLinesColor,TF2_UpperSupportLine_array,TF2_NumZones,TF2_SupportZone, TF2_LowerSupportLine_array,TF2_input,TF2SupLabel_array,bar_index[TF2_Lo_Bi], bar_index[3], bar_index,bar_index[2], TF2_extRight)
else if (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and na(TF2_FractalDown != TF2_FractalDown[1]) and chartOnLowerTF2 and na(ta.barssince(TF2_FractalDown != TF2_FractalDown[1])) 
    TF_SupportLineB(TF2_FractalDown,TF2_SupLinesColor,TF2_UpperSupportLine_array,TF2_NumZones,TF2_SupportZone,TF2_LowerSupportLine_array,TF2_input,TF2SupLabel_array,bar_index[3],bar_index, TF2_extRight)

if (TF2_Menu == 'S/R Zones')
    linefill.new(array.get(TF2_UpperSupportLine_array, TF2_NumZones-1), array.get(TF2_LowerSupportLine_array, TF2_NumZones-1), TF2_SupZoneColor)

if ShowLabel == true and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF2_FractalDown, TF2_input+"(S)", TF2_SupLinesColor, TF2SupLabel_array)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF2_UpperResLine_array, TF2_NumZones-1), extend.none)
    line.set_x2(array.get(TF2_UpperResLine_array, TF2_NumZones-1), bar_index)
    line.set_extend(array.get(TF2_LowerResLine_array, TF2_NumZones-1), extend.none)
    line.set_x2(array.get(TF2_LowerResLine_array, TF2_NumZones-1), bar_index)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF2_UpperSupportLine_array, TF2_NumZones-1), extend.none)
    line.set_x2(array.get(TF2_UpperSupportLine_array, TF2_NumZones-1), bar_index)
    line.set_extend(array.get(TF2_LowerSupportLine_array, TF2_NumZones-1), extend.none)
    line.set_x2(array.get(TF2_LowerSupportLine_array, TF2_NumZones-1), bar_index)

// S/R  = Time Frame 3 = TF3
TF3_Vol = f_tfSources(TF3, volume)
TF3_VolMA = ta.sma(TF3_Vol, TF3_VolMA1Input)
TF3_High = f_tfSources(TF3, high)
TF3_Low = f_tfSources(TF3, low)
TF3_Open = f_tfSources(TF3, open)
TF3_Close = f_tfSources(TF3, close)

TF3_Up = f_tfUp(TF3_High, TF3_Vol, TF3_VolMA)
TF3_Down = f_tfDown(TF3_Low, TF3_Vol, TF3_VolMA)

TF3_CalcFractalUp() =>
    TF3_FractalUp = 0.0
    TF3_FractalUp := TF3_Up ? TF3_High[3] : TF3_FractalUp[1]
    TF3_FractalUp

TF3_CalcFractalDown() =>
    TF3_FractalDown = 0.0
    TF3_FractalDown := TF3_Down ? TF3_Low[3] : TF3_FractalDown[1]
    TF3_FractalDown

TF3_FractalUp = request.security(syminfo.tickerid, TF3, TF3_CalcFractalUp())
TF3_FractalDown = request.security(syminfo.tickerid, TF3, TF3_CalcFractalDown())

// Zones - Current Time Frame = Time Frame 3 = TF3
// Fractal Up Zones
TF3_CalcFractalUpZone() =>
    TF3_FractalUpZone = 0.0
    TF3_FractalUpZone := TF3_Up and TF3_Close[3] >= TF3_Open[3] ? TF3_Close[3] : TF3_Up and TF3_Close[3] < TF3_Open[3] ? TF3_Open[3] : TF3_FractalUpZone[1]
    TF3_FractalUpZone

TF3_FractalUpZone = request.security(syminfo.tickerid, TF3, TF3_CalcFractalUpZone())
TF3_ResZone = TF3_FractalUpZone

// Fractal Down Zones
TF3_CalcFractalDownZone() =>
    TF3_FractalDownZone = 0.0
    TF3_FractalDownZone := TF3_Down and TF3_Close[3] >= TF3_Open[3] ? TF3_Open[3] : TF3_Down and TF3_Close[3] < TF3_Open[3] ? TF3_Close[3] : TF3_FractalDownZone[1]
    TF3_FractalDownZone

TF3_FractalDownZone = request.security(syminfo.tickerid, TF3, TF3_CalcFractalDownZone())
TF3_SupportZone = TF3_FractalDownZone

// Time Frame 3 = TF3 Resistance
if (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and TF3_FractalUp != TF3_FractalUp[1] and chartOnLowerTF3
    TF_ResistanceLineA(TF3_input,TF3_FractalUp,TF3_ResLinesColor,TF3_UpperResLine_array,TF3_NumZones,TF3_ResZone, TF3_LowerResLine_array,TF3_input,TF3ResLabel_array,bar_index[TF3_Hi_Bi], bar_index[3], bar_index,bar_index[2], TF3_extRight)
else if (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and na(TF3_FractalUp != TF3_FractalUp[1]) and chartOnLowerTF3 and na(ta.barssince(TF3_FractalUp != TF3_FractalUp[1]))
    TF_ResistanceLineB(TF3_FractalUp,TF3_ResLinesColor,TF3_UpperResLine_array,TF3_NumZones,TF3_ResZone,TF3_LowerResLine_array,TF3_input,TF3ResLabel_array,bar_index[3],bar_index, TF3_extRight)

if (TF3_Menu == 'S/R Zones')
    linefill.new(array.get(TF3_UpperResLine_array, TF3_NumZones-1), array.get(TF3_LowerResLine_array, TF3_NumZones-1), TF3_ResZoneColor)

if ShowLabel == true and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and chartOnLowerTF3 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF3_FractalUp, TF3_input+"(R)", TF3_ResLinesColor, TF3ResLabel_array)


// Time Frame 3 = TF3 Support
if (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and TF3_FractalDown != TF3_FractalDown[1] and chartOnLowerTF3
    TF_SupportLineA(TF3_input,TF3_FractalDown,TF3_SupLinesColor,TF3_UpperSupportLine_array,TF3_NumZones,TF3_SupportZone, TF3_LowerSupportLine_array,TF3_input,TF3SupLabel_array,bar_index[TF3_Lo_Bi], bar_index[3], bar_index,bar_index[2], TF3_extRight)
else if (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and na(TF3_FractalDown != TF3_FractalDown[1]) and chartOnLowerTF3 and na(ta.barssince(TF3_FractalDown != TF3_FractalDown[1])) 
    TF_SupportLineB(TF3_FractalDown,TF3_SupLinesColor,TF3_UpperSupportLine_array,TF3_NumZones,TF3_SupportZone,TF3_LowerSupportLine_array,TF3_input,TF3SupLabel_array,bar_index[3],bar_index, TF3_extRight)

if (TF3_Menu == 'S/R Zones')
    linefill.new(array.get(TF3_UpperSupportLine_array, TF3_NumZones-1), array.get(TF3_LowerSupportLine_array, TF3_NumZones-1), TF3_SupZoneColor)

if ShowLabel == true and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and chartOnLowerTF3 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF3_FractalDown, TF3_input+"(S)", TF3_SupLinesColor, TF3SupLabel_array)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF3_UpperResLine_array, TF3_NumZones-1), extend.none)
    line.set_x2(array.get(TF3_UpperResLine_array, TF3_NumZones-1), bar_index)
    line.set_extend(array.get(TF3_LowerResLine_array, TF3_NumZones-1), extend.none)
    line.set_x2(array.get(TF3_LowerResLine_array, TF3_NumZones-1), bar_index)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF3_UpperSupportLine_array, TF3_NumZones-1), extend.none)
    line.set_x2(array.get(TF3_UpperSupportLine_array, TF3_NumZones-1), bar_index)
    line.set_extend(array.get(TF3_LowerSupportLine_array, TF3_NumZones-1), extend.none)
    line.set_x2(array.get(TF3_LowerSupportLine_array, TF3_NumZones-1), bar_index)

// S/R  = Time Frame 4 = TF4
TF4_Vol = f_tfSources(TF4, volume)
TF4_VolMA = ta.sma(TF4_Vol, TF4_VolMA1Input)
TF4_High = f_tfSources(TF4, high)
TF4_Low = f_tfSources(TF4, low)
TF4_Open = f_tfSources(TF4, open)
TF4_Close = f_tfSources(TF4, close)

TF4_Up = f_tfUp(TF4_High, TF4_Vol, TF4_VolMA)
TF4_Down = f_tfDown(TF4_Low, TF4_Vol, TF4_VolMA)

TF4_CalcFractalUp() =>
    TF4_FractalUp = 0.0
    TF4_FractalUp := TF4_Up ? TF4_High[3] : TF4_FractalUp[1]
    TF4_FractalUp

TF4_CalcFractalDown() =>
    TF4_FractalDown = 0.0
    TF4_FractalDown := TF4_Down ? TF4_Low[3] : TF4_FractalDown[1]
    TF4_FractalDown

TF4_FractalUp = request.security(syminfo.tickerid, TF4, TF4_CalcFractalUp())
TF4_FractalDown = request.security(syminfo.tickerid, TF4, TF4_CalcFractalDown())

// Zones - Current Time Frame = Time Frame 4 = TF4
// Fractal Up Zones
TF4_CalcFractalUpZone() =>
    TF4_FractalUpZone = 0.0
    TF4_FractalUpZone := TF4_Up and TF4_Close[3] >= TF4_Open[3] ? TF4_Close[3] : TF4_Up and TF4_Close[3] < TF4_Open[3] ? TF4_Open[3] : TF4_FractalUpZone[1]
    TF4_FractalUpZone

TF4_FractalUpZone = request.security(syminfo.tickerid, TF4, TF4_CalcFractalUpZone())
TF4_ResZone = TF4_FractalUpZone

// Fractal Down Zones
TF4_CalcFractalDownZone() =>
    TF4_FractalDownZone = 0.0
    TF4_FractalDownZone := TF4_Down and TF4_Close[3] >= TF4_Open[3] ? TF4_Open[3] : TF4_Down and TF4_Close[3] < TF4_Open[3] ? TF4_Close[3] : TF4_FractalDownZone[1]
    TF4_FractalDownZone

TF4_FractalDownZone = request.security(syminfo.tickerid, TF4, TF4_CalcFractalDownZone())
TF4_SupportZone = TF4_FractalDownZone

// Time Frame 4 = TF4 Resistance
if (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and TF4_FractalUp != TF4_FractalUp[1] and chartOnLowerTF4
    TF_ResistanceLineA(TF4_input,TF4_FractalUp,TF4_ResLinesColor,TF4_UpperResLine_array,TF4_NumZones,TF4_ResZone, TF4_LowerResLine_array,TF4_input,TF4ResLabel_array,bar_index[TF4_Hi_Bi], bar_index[3], bar_index,bar_index[2], TF4_extRight)
else if (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and na(TF4_FractalUp != TF4_FractalUp[1]) and chartOnLowerTF4 and na(ta.barssince(TF4_FractalUp != TF4_FractalUp[1]))
    TF_ResistanceLineB(TF4_FractalUp,TF4_ResLinesColor,TF4_UpperResLine_array,TF4_NumZones,TF4_ResZone,TF4_LowerResLine_array,TF4_input,TF4ResLabel_array,bar_index[3],bar_index, TF4_extRight)

if (TF4_Menu == 'S/R Zones')
    linefill.new(array.get(TF4_UpperResLine_array, TF4_NumZones-1), array.get(TF4_LowerResLine_array, TF4_NumZones-1), TF4_ResZoneColor)

if ShowLabel == true and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and chartOnLowerTF4 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF4_FractalUp, TF4_input+"(R)", TF4_ResLinesColor, TF4ResLabel_array)


// Time Frame 4 = TF4 Support
if (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and TF4_FractalDown != TF4_FractalDown[1] and chartOnLowerTF4
    TF_SupportLineA(TF4_input,TF4_FractalDown,TF4_SupLinesColor,TF4_UpperSupportLine_array,TF4_NumZones,TF4_SupportZone, TF4_LowerSupportLine_array,TF4_input,TF4SupLabel_array,bar_index[TF4_Lo_Bi], bar_index[3], bar_index,bar_index[2], TF4_extRight)
else if (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and na(TF4_FractalDown != TF4_FractalDown[1]) and chartOnLowerTF4 and na(ta.barssince(TF4_FractalDown != TF4_FractalDown[1])) 
    TF_SupportLineB(TF4_FractalDown,TF4_SupLinesColor,TF4_UpperSupportLine_array,TF4_NumZones,TF4_SupportZone,TF4_LowerSupportLine_array,TF4_input,TF4SupLabel_array,bar_index[3],bar_index, TF4_extRight)

if (TF4_Menu == 'S/R Zones')
    linefill.new(array.get(TF4_UpperSupportLine_array, TF4_NumZones-1), array.get(TF4_LowerSupportLine_array, TF4_NumZones-1), TF4_SupZoneColor)

if ShowLabel == true and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and chartOnLowerTF4 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF4_FractalDown, TF4_input+"(S)", TF4_SupLinesColor, TF4SupLabel_array)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF4_UpperResLine_array, TF4_NumZones-1), extend.none)
    line.set_x2(array.get(TF4_UpperResLine_array, TF4_NumZones-1), bar_index)
    line.set_extend(array.get(TF4_LowerResLine_array, TF4_NumZones-1), extend.none)
    line.set_x2(array.get(TF4_LowerResLine_array, TF4_NumZones-1), bar_index)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF4_UpperSupportLine_array, TF4_NumZones-1), extend.none)
    line.set_x2(array.get(TF4_UpperSupportLine_array, TF4_NumZones-1), bar_index)
    line.set_extend(array.get(TF4_LowerSupportLine_array, TF4_NumZones-1), extend.none)
    line.set_x2(array.get(TF4_LowerSupportLine_array, TF4_NumZones-1), bar_index)

// ---------- The following lines modify the labels when there is the same S/R zone found on 2 different time frames, to combine both into one label and take the color of the higher time frame.
// ---------- This prevents 2 labels from being displayed on top of each other. For left labels, extra lines are required to reset the labels back to their original form once the SR changes for the lower time frame.

if label_loc == 'Right'
    if TF4_FractalUp == TF3_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and chartOnLowerTF3 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF3ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF3_input + '/' + TF4_input + "(R)")
    if TF4_FractalUp == TF2_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF2ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF2_input + '/' + TF4_input + "(R)")
    if TF4_FractalUp == TF1_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF4 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF1ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF1_text + '/' + TF4_input + "(R)")
    if TF3_FractalUp == TF2_FractalUp and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and not chartEqualTF3
        label.set_textcolor(id=array.get(TF2ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF3ResLabel_array, 0), text=TF2_input + '/' + TF3_input + "(R)")
    if TF3_FractalUp == TF1_FractalUp and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF3 and not chartEqualTF3
        label.set_textcolor(id=array.get(TF1ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF3ResLabel_array, 0), text=TF1_text + '/' + TF3_input + "(R)")
    if TF2_FractalUp == TF1_FractalUp and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF2 and not chartEqualTF2
        label.set_textcolor(id=array.get(TF1ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF2ResLabel_array, 0), text=TF1_text + '/' + TF2_input + "(R)")
    if TF4_FractalDown == TF3_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and chartOnLowerTF3 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF3SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF3_input + '/' + TF4_input + "(S)")
    if TF4_FractalDown == TF2_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF2SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF2_input + '/' + TF4_input + "(S)")
    if TF4_FractalDown == TF1_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF4 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF1SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF1_text + '/' + TF4_input + "(S)")
    if TF3_FractalDown == TF2_FractalDown and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and not chartEqualTF3
        label.set_textcolor(id=array.get(TF2SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF3SupLabel_array, 0), text=TF2_input + '/' + TF3_input + "(S)")
    if TF3_FractalDown == TF1_FractalDown and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF3 and not chartEqualTF3
        label.set_textcolor(id=array.get(TF1SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF3SupLabel_array, 0), text=TF1_text + '/' + TF3_input + "(S)")
    if TF2_FractalDown == TF1_FractalDown and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF2 and not chartEqualTF2
        label.set_textcolor(id=array.get(TF1SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF2SupLabel_array, 0), text=TF1_text + '/' + TF2_input + "(S)")

// Left Labels
if label_loc == 'Left'
    if TF4_FractalUp == TF3_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and chartOnLowerTF3 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF3ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF3_input + '/' + TF4_input + "(R)")
    if TF4_FractalUp[1] == TF3_FractalUp[1] and TF4_FractalUp != TF3_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R')
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF4_input + "(R)")
    if TF4_FractalUp == TF2_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF2ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF2_input + '/' + TF4_input + "(R)")
    if TF4_FractalUp[1] == TF2_FractalUp[1] and TF4_FractalUp != TF2_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R')
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF4_input + "(R)")
    if TF4_FractalUp == TF1_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF4 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF1ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF1_text + '/' + TF4_input + "(R)")
    if TF4_FractalUp[1] == TF1_FractalUp[1] and TF4_FractalUp != TF1_FractalUp and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R')
        label.set_text(id=array.get(TF4ResLabel_array, 0), text=TF4_input + "(R)")
    if TF3_FractalUp == TF2_FractalUp and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and not chartEqualTF3
        label.set_textcolor(id=array.get(TF2ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF3ResLabel_array, 0), text=TF2_input + '/' + TF3_input + "(R)")
    if TF3_FractalUp[1] == TF2_FractalUp[1] and TF3_FractalUp != TF2_FractalUp and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R')
        label.set_text(id=array.get(TF3ResLabel_array, 0), text=TF3_input + "(R)")
    if TF3_FractalUp == TF1_FractalUp and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF3 and not chartEqualTF3
        label.set_textcolor(id=array.get(TF1ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF3ResLabel_array, 0), text=TF1_text + '/' + TF3_input + "(R)")
    if TF3_FractalUp[1] == TF1_FractalUp[1] and TF3_FractalUp != TF1_FractalUp and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R')
        label.set_text(id=array.get(TF3ResLabel_array, 0), text=TF3_input + "(R)")
    if TF2_FractalUp == TF1_FractalUp and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF2 and not chartEqualTF2
        label.set_textcolor(id=array.get(TF1ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF2ResLabel_array, 0), text=TF1_text + '/' + TF2_input + "(R)")
    if TF2_FractalUp[1] == TF1_FractalUp[1] and TF2_FractalUp != TF1_FractalUp and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R')
        label.set_text(id=array.get(TF2ResLabel_array, 0), text=TF2_input + "(R)")
    if TF4_FractalDown == TF3_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and chartOnLowerTF3 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF3SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF3_input + '/' + TF4_input + "(S)")
    if TF4_FractalDown[1] == TF3_FractalDown[1] and TF4_FractalDown != TF3_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R')
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF4_input + "(S)")
    if TF4_FractalDown == TF2_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF2SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF2_input + '/' + TF4_input + "(S)")
    if TF4_FractalDown[1] == TF2_FractalDown[1] and TF4_FractalDown != TF2_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R')
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF4_input + "(S)")
    if TF4_FractalDown == TF1_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF4 and not chartEqualTF4
        label.set_textcolor(id=array.get(TF1SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF1_text + '/' + TF4_input + "(S)")
    if TF4_FractalDown[1] == TF1_FractalDown[1] and TF4_FractalDown != TF1_FractalDown and (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R')
        label.set_text(id=array.get(TF4SupLabel_array, 0), text=TF4_input + "(S)")
    if TF3_FractalDown == TF2_FractalDown and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and not chartEqualTF3
        label.set_textcolor(id=array.get(TF2SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF3SupLabel_array, 0), text=TF2_input + '/' + TF3_input + "(S)")
    if TF3_FractalDown[1] == TF2_FractalDown[1] and TF2_FractalDown != TF3_FractalDown and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R')
        label.set_text(id=array.get(TF3SupLabel_array, 0), text=TF3_input + "(S)")
    if TF3_FractalDown == TF1_FractalDown and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF3 and not chartEqualTF3
        label.set_textcolor(id=array.get(TF1SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF3SupLabel_array, 0), text=TF1_text + '/' + TF3_input + "(S)")
    if TF3_FractalDown[1] == TF1_FractalDown[1] and TF3_FractalDown != TF1_FractalDown and (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R')
        label.set_text(id=array.get(TF3SupLabel_array, 0), text=TF3_input + "(S)")
    if TF2_FractalDown == TF1_FractalDown and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF2 and not chartEqualTF2
        label.set_textcolor(id=array.get(TF1SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF2SupLabel_array, 0), text=TF1_text + '/' + TF2_input + "(S)")
    if TF2_FractalDown[1] == TF1_FractalDown[1] and TF2_FractalDown != TF1_FractalDown and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R')
        label.set_text(id=array.get(TF2SupLabel_array, 0), text=TF2_input + "(S)")

// ---------------- Alerts
// TF1
PriceEntersTF1ResZone = ta.crossover(close, TF1_ResZone)
PriceTestResAsSupportTF1 = ta.crossunder(close, TF1_FractalUp)
PriceEntersTF1SupZone = ta.crossunder(close, TF1_SupportZone)
PriceTestSupportAsResTF1 = ta.crossover(close, TF1_FractalDown)
PriceBreakingTF1Resistance = ta.crossover(close, TF1_FractalUp)
PriceBreakingTF1Support = ta.crossunder(close, TF1_FractalDown)
NewResFoundTF1 = (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and TF1_FractalUp != TF1_FractalUp[1]
NewSupFoundTF1 = (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and TF1_FractalDown != TF1_FractalDown[1]

if (TF1_Alerts == 'Price Enters Resistance Zone' or TF1_Alerts == 'Price Enters Either S/R Zone' or TF1_Alerts == 'All Alerts On') and PriceEntersTF1ResZone
    alert(syminfo.ticker + ' - Price enters ' + TF1_text + ' Resistance Zone', alert.freq_once_per_bar)

if (TF1_Alerts == 'Price Enters Resistance Zone' or TF1_Alerts == 'Price Enters Either S/R Zone' or TF1_Alerts == 'All Alerts On') and PriceTestResAsSupportTF1
    alert(syminfo.ticker + ' - Price is testing ' + TF1_text + ' resistance as support', alert.freq_once_per_bar)

if (TF1_Alerts == 'Price Enters Support Zone' or TF1_Alerts == 'Price Enters Either S/R Zone' or TF1_Alerts == 'All Alerts On') and PriceEntersTF1SupZone
    alert(syminfo.ticker + ' - Price enters ' + TF1_text + ' Support Zone', alert.freq_once_per_bar)

if (TF1_Alerts == 'Price Enters Support Zone' or TF1_Alerts == 'Price Enters Either S/R Zone' or TF1_Alerts == 'All Alerts On') and PriceTestSupportAsResTF1
    alert(syminfo.ticker + ' - Price is testing ' + TF1_text + ' support as resistance', alert.freq_once_per_bar)

if (TF1_Alerts == 'Price Breaks Resistance' or TF1_Alerts == 'Price Breaks Either S/R' or TF1_Alerts == 'All Alerts On') and PriceBreakingTF1Resistance
    alert(syminfo.ticker + ' - Price is breaking out ' + TF1_text + ' Resistance', alert.freq_once_per_bar)

if (TF1_Alerts == 'Price Breaks Support' or TF1_Alerts == 'Price Breaks Either S/R' or TF1_Alerts == 'All Alerts On') and PriceBreakingTF1Support
    alert(syminfo.ticker + ' - Price is breaking down ' + TF1_text + ' Support', alert.freq_once_per_bar)

if (TF1_Alerts == 'New S/R Zone Found' or TF1_Alerts == 'All Alerts On')
    if NewResFoundTF1
        alert(syminfo.ticker + ' - New ' + TF1_text + ' Resistance Zone Found', alert.freq_once_per_bar)
    if NewSupFoundTF1
        alert(syminfo.ticker + ' - New ' + TF1_text + ' Support Zone Found', alert.freq_once_per_bar)

// TF2
PriceEntersTF2ResZone = ta.crossover(close, TF2_ResZone)
PriceTestResAsSupportTF2 = ta.crossunder(close, TF2_FractalUp)
PriceEntersTF2SupZone = ta.crossunder(close, TF2_SupportZone)
PriceTestSupportAsResTF2 = ta.crossover(close, TF2_FractalDown)
PriceBreakingTF2Resistance = ta.crossover(close, TF2_FractalUp)
PriceBreakingTF2Support = ta.crossunder(close, TF2_FractalDown)
NewResFoundTF2 = (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and TF2_FractalUp != TF2_FractalUp[1]
NewSupFoundTF2 = (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and TF2_FractalDown != TF2_FractalDown[1]

if (TF2_Alerts == 'Price Enters Resistance Zone' or TF2_Alerts == 'Price Enters Either S/R Zone' or TF2_Alerts == 'All Alerts On') and PriceEntersTF2ResZone
    alert(syminfo.ticker + ' - Price enters ' + TF2_input + ' Resistance Zone', alert.freq_once_per_bar)

if (TF2_Alerts == 'Price Enters Resistance Zone' or TF2_Alerts == 'Price Enters Either S/R Zone' or TF2_Alerts == 'All Alerts On') and PriceTestResAsSupportTF2
    alert(syminfo.ticker + ' - Price is testing ' + TF2_input + ' resistance as support', alert.freq_once_per_bar)

if (TF2_Alerts == 'Price Enters Support Zone' or TF2_Alerts == 'Price Enters Either S/R Zone' or TF2_Alerts == 'All Alerts On') and PriceEntersTF2SupZone
    alert(syminfo.ticker + ' - Price enters ' + TF2_input + ' Support Zone', alert.freq_once_per_bar)

if (TF2_Alerts == 'Price Enters Support Zone' or TF2_Alerts == 'Price Enters Either S/R Zone' or TF2_Alerts == 'All Alerts On') and PriceTestSupportAsResTF2
    alert(syminfo.ticker + ' - Price is testing ' + TF2_input + ' support as resistance', alert.freq_once_per_bar)

if (TF2_Alerts == 'Price Breaks Resistance' or TF2_Alerts == 'Price Breaks Either S/R' or TF2_Alerts == 'All Alerts On') and PriceBreakingTF2Resistance
    alert(syminfo.ticker + ' - Price is breaking out ' + TF2_input + ' Resistance', alert.freq_once_per_bar)

if (TF2_Alerts == 'Price Breaks Support' or TF2_Alerts == 'Price Breaks Either S/R' or TF2_Alerts == 'All Alerts On') and PriceBreakingTF2Support
    alert(syminfo.ticker + ' - Price is breaking down ' + TF2_input + ' Support', alert.freq_once_per_bar)

if (TF2_Alerts == 'New S/R Zone Found' or TF2_Alerts == 'All Alerts On')
    if NewResFoundTF2
        alert(syminfo.ticker + ' - New ' + TF2_input + ' Resistance Zone Found', alert.freq_once_per_bar)
    if NewSupFoundTF2
        alert(syminfo.ticker + ' - New ' + TF2_input + ' Support Zone Found', alert.freq_once_per_bar)

// TF3
PriceEntersTF3ResZone = ta.crossover(close, TF3_ResZone)
PriceTestResAsSupportTF3 = ta.crossunder(close, TF3_FractalUp)
PriceEntersTF3SupZone = ta.crossunder(close, TF3_SupportZone)
PriceTestSupportAsResTF3 = ta.crossover(close, TF3_FractalDown)
PriceBreakingTF3Resistance = ta.crossover(close, TF3_FractalUp)
PriceBreakingTF3Support = ta.crossunder(close, TF3_FractalDown)
NewResFoundTF3 = (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and TF3_FractalUp != TF3_FractalUp[1]
NewSupFoundTF3 = (TF3_Menu == 'S/R Zones' or TF3_Menu == 'S/R') and TF3_FractalDown != TF3_FractalDown[1]

if (TF3_Alerts == 'Price Enters Resistance Zone' or TF3_Alerts == 'Price Enters Either S/R Zone' or TF3_Alerts == 'All Alerts On') and PriceEntersTF3ResZone
    alert(syminfo.ticker + ' - Price enters ' + TF3_input + ' Resistance Zone', alert.freq_once_per_bar)

if (TF3_Alerts == 'Price Enters Resistance Zone' or TF3_Alerts == 'Price Enters Either S/R Zone' or TF3_Alerts == 'All Alerts On') and PriceTestResAsSupportTF3
    alert(syminfo.ticker + ' - Price is testing ' + TF3_input + ' resistance as support', alert.freq_once_per_bar)

if (TF3_Alerts == 'Price Enters Support Zone' or TF3_Alerts == 'Price Enters Either S/R Zone' or TF3_Alerts == 'All Alerts On') and PriceEntersTF3SupZone
    alert(syminfo.ticker + ' - Price enters ' + TF3_input + ' Support Zone', alert.freq_once_per_bar)

if (TF3_Alerts == 'Price Enters Support Zone' or TF3_Alerts == 'Price Enters Either S/R Zone' or TF3_Alerts == 'All Alerts On') and PriceTestSupportAsResTF3
    alert(syminfo.ticker + ' - Price is testing ' + TF3_input + ' support as resistance', alert.freq_once_per_bar)

if (TF3_Alerts == 'Price Breaks Resistance' or TF3_Alerts == 'Price Breaks Either S/R' or TF3_Alerts == 'All Alerts On') and PriceBreakingTF3Resistance
    alert(syminfo.ticker + ' - Price is breaking out ' + TF3_input + ' Resistance', alert.freq_once_per_bar)

if (TF3_Alerts == 'Price Breaks Support' or TF3_Alerts == 'Price Breaks Either S/R' or TF3_Alerts == 'All Alerts On') and PriceBreakingTF3Support
    alert(syminfo.ticker + ' - Price is breaking down ' + TF3_input + ' Support', alert.freq_once_per_bar)

if (TF3_Alerts == 'New S/R Zone Found' or TF3_Alerts == 'All Alerts On')
    if NewResFoundTF3
        alert(syminfo.ticker + ' - New ' + TF3_input + ' Resistance Zone Found', alert.freq_once_per_bar)
    if NewSupFoundTF3
        alert(syminfo.ticker + ' - New ' + TF3_input + ' Support Zone Found', alert.freq_once_per_bar)

// TF4
PriceEntersTF4ResZone = ta.crossover(close, TF4_ResZone)
PriceTestResAsSupportTF4 = ta.crossunder(close, TF4_FractalUp)
PriceEntersTF4SupZone = ta.crossunder(close, TF4_SupportZone)
PriceTestSupportAsResTF4 = ta.crossover(close, TF4_FractalDown)
PriceBreakingTF4Resistance = ta.crossover(close, TF4_FractalUp)
PriceBreakingTF4Support = ta.crossunder(close, TF4_FractalDown)
NewResFoundTF4 = (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and TF4_FractalUp != TF4_FractalUp[1]
NewSupFoundTF4 = (TF4_Menu == 'S/R Zones' or TF4_Menu == 'S/R') and TF4_FractalDown != TF4_FractalDown[1]

if (TF4_Alerts == 'Price Enters Resistance Zone' or TF4_Alerts == 'Price Enters Either S/R Zone' or TF4_Alerts == 'All Alerts On') and PriceEntersTF4ResZone
    alert(syminfo.ticker + ' - Price enters ' + TF4_input + ' Resistance Zone', alert.freq_once_per_bar)

if (TF4_Alerts == 'Price Enters Resistance Zone' or TF4_Alerts == 'Price Enters Either S/R Zone' or TF4_Alerts == 'All Alerts On') and PriceTestResAsSupportTF4
    alert(syminfo.ticker + ' - Price is testing ' + TF4_input + ' resistance as support', alert.freq_once_per_bar)

if (TF4_Alerts == 'Price Enters Support Zone' or TF4_Alerts == 'Price Enters Either S/R Zone' or TF4_Alerts == 'All Alerts On') and PriceEntersTF4SupZone
    alert(syminfo.ticker + ' - Price enters ' + TF4_input + ' Support Zone', alert.freq_once_per_bar)

if (TF4_Alerts == 'Price Enters Support Zone' or TF4_Alerts == 'Price Enters Either S/R Zone' or TF4_Alerts == 'All Alerts On') and PriceTestSupportAsResTF4
    alert(syminfo.ticker + ' - Price is testing ' + TF4_input + ' support as resistance', alert.freq_once_per_bar)

if (TF4_Alerts == 'Price Breaks Resistance' or TF4_Alerts == 'Price Breaks Either S/R' or TF4_Alerts == 'All Alerts On') and PriceBreakingTF4Resistance
    alert(syminfo.ticker + ' - Price is breaking out ' + TF4_input + ' Resistance', alert.freq_once_per_bar)

if (TF4_Alerts == 'Price Breaks Support' or TF4_Alerts == 'Price Breaks Either S/R' or TF4_Alerts == 'All Alerts On') and PriceBreakingTF4Support
    alert(syminfo.ticker + ' - Price is breaking down ' + TF4_input + ' Support', alert.freq_once_per_bar)

if (TF4_Alerts == 'New S/R Zone Found' or TF4_Alerts == 'All Alerts On')
    if NewResFoundTF4
        alert(syminfo.ticker + ' - New ' + TF4_input + ' Resistance Zone Found', alert.freq_once_per_bar)
    if NewSupFoundTF4
        alert(syminfo.ticker + ' - New ' + TF4_input + ' Support Zone Found', alert.freq_once_per_bar)
